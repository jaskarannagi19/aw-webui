{"remainingRequest":"/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/src/visualizations/SunburstClock.vue?vue&type=style&index=0&id=2920aaea&scoped=true&lang=scss&","dependencies":[{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/src/visualizations/SunburstClock.vue","mtime":1622830085278},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server-rust/aw-webui/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCi5zdW5idXJzdCB7CiAgZm9udC1mYW1pbHk6ICdPcGVuIFNhbnMnLCBzYW5zLXNlcmlmOwogIGZvbnQtc2l6ZTogMTJweDsKICBmb250LXdlaWdodDogNDAwOwogIHdpZHRoOiAxMDAlOwogIGhlaWdodDogNjIwcHg7CiAgbWFyZ2luLXRvcDogMTBweDsKCiAgLm1haW4gewogICAgd2lkdGg6IDc1MHB4OwogICAgbWFyZ2luLXJpZ2h0OiBhdXRvOwogICAgbWFyZ2luLWxlZnQ6IGF1dG87CiAgfQoKICAuc2lkZWJhciB7CiAgICBmbG9hdDogbGVmdDsKICAgIGhlaWdodDogMDsKICAgIHdpZHRoOiAxMDBweDsKICB9CgogIC5zZXF1ZW5jZSB7CiAgICB3aWR0aDogNjAwcHg7CiAgICBoZWlnaHQ6IDcwcHg7CiAgfQoKICAubGVnZW5kIHsKICAgIHBhZGRpbmc6IDEwcHggMCAwIDNweDsKICB9CgogIC5zZXF1ZW5jZSB0ZXh0LAogIC5sZWdlbmQgdGV4dCB7CiAgICBmb250LXdlaWdodDogNjAwOwogICAgZmlsbDogI2ZmZjsKICB9CgogIC5jaGFydCB7CiAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgfQoKICAuY2hhcnQgcGF0aCB7CiAgICBzdHJva2U6ICNmZmY7CiAgfQoKICAuZXhwbGFuYXRpb24gewogICAgcG9zaXRpb246IGFic29sdXRlOwogICAgdG9wOiAyNjBweDsKICAgIGxlZnQ6IDMwNXB4OwogICAgd2lkdGg6IDE0MHB4OwogICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgY29sb3I6ICM2NjY7CiAgICB6LWluZGV4OiAxMDsgLy8gbWlnaHQgbm90IGJlIG5lZWRlZAoKICAgIC5iYXNlIHsKICAgICAgY29sb3I6ICNkZGQ7CiAgICAgIGZvbnQtc2l6ZTogMmVtOwogICAgfQoKICAgIC5ob3ZlciB7CiAgICAgIC5kYXRlIHsKICAgICAgICBmb250LXNpemU6IDAuOGVtOwogICAgICB9CgogICAgICAudGltZSB7CiAgICAgICAgZm9udC1zaXplOiAxZW07CiAgICAgIH0KCiAgICAgIC50aXRsZSB7CiAgICAgICAgZm9udC1zaXplOiAyZW07CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICAgIH0KCiAgICAgIC5kdXJhdGlvbiB7CiAgICAgICAgZm9udC1zaXplOiAxZW07CiAgICAgIH0KCiAgICAgIC5kYXRhIHsKICAgICAgICBmb250LXNpemU6IDFlbTsKICAgICAgfQogICAgfQogIH0KfQo="},{"version":3,"sources":["SunburstClock.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"SunburstClock.vue","sourceRoot":"src/visualizations","sourcesContent":["<template lang=\"pug\">\ndiv.sunburst\n  div.sidebar\n    div.legend\n\n  div.main\n    div.chart\n      div.explanation\n        div.base\n          | {{ centerMsg }}\n        div.hover(style=\"visibility: hidden\")\n          div.date\n          div.title\n          div.time\n          div.duration\n          div.data(style=\"text-overflow: ellipsis; white-space: nowrap; overflow: hidden;\")\n</template>\n\n<style scoped lang=\"scss\">\n.sunburst {\n  font-family: 'Open Sans', sans-serif;\n  font-size: 12px;\n  font-weight: 400;\n  width: 100%;\n  height: 620px;\n  margin-top: 10px;\n\n  .main {\n    width: 750px;\n    margin-right: auto;\n    margin-left: auto;\n  }\n\n  .sidebar {\n    float: left;\n    height: 0;\n    width: 100px;\n  }\n\n  .sequence {\n    width: 600px;\n    height: 70px;\n  }\n\n  .legend {\n    padding: 10px 0 0 3px;\n  }\n\n  .sequence text,\n  .legend text {\n    font-weight: 600;\n    fill: #fff;\n  }\n\n  .chart {\n    position: relative;\n  }\n\n  .chart path {\n    stroke: #fff;\n  }\n\n  .explanation {\n    position: absolute;\n    top: 260px;\n    left: 305px;\n    width: 140px;\n    text-align: center;\n    color: #666;\n    z-index: 10; // might not be needed\n\n    .base {\n      color: #ddd;\n      font-size: 2em;\n    }\n\n    .hover {\n      .date {\n        font-size: 0.8em;\n      }\n\n      .time {\n        font-size: 1em;\n      }\n\n      .title {\n        font-size: 2em;\n        font-weight: bold;\n      }\n\n      .duration {\n        font-size: 1em;\n      }\n\n      .data {\n        font-size: 1em;\n      }\n    }\n  }\n}\n</style>\n\n<script>\n// NOTE: This is just a Vue.js component wrapper for timeline-simple.js\n//       Code should generally go in the framework-independent file.\n\n// TODO: Sunburst requires a hierarchical data format\n\nimport sunburst from './sunburst-clock.js';\nimport moment from 'moment';\nimport _ from 'lodash';\n\nexport default {\n  name: 'aw-sunburst-clock',\n  props: {\n    date: { type: String },\n    afkBucketId: { type: String },\n    windowBucketId: { type: String },\n  },\n\n  data: () => {\n    return {\n      starttime: moment(),\n      endtime: moment(),\n      centerMsg: 'Loading...',\n    };\n  },\n\n  watch: {\n    date: function (to) {\n      this.starttime = moment(to);\n      this.endtime = moment(this.starttime).add(1, 'days');\n      this.visualize();\n    },\n  },\n  mounted: function () {\n    sunburst.create(this.$el);\n    this.starttime = moment(this.date);\n    this.endtime = moment(this.date).add(1, 'days');\n    this.visualize();\n  },\n\n  methods: {\n    todaysEvents: async function (bucket_id) {\n      const querystr = [`RETURN = flood(query_bucket(\"${bucket_id}\"));`];\n      const data = await this.$aw.query(\n        [`${this.starttime.format()}/${this.endtime.format()}`],\n        querystr\n      );\n      return data[0];\n    },\n\n    visualize: function () {\n      function buildHierarchy(parents, children) {\n        parents = _.sortBy(parents, 'timestamp', 'desc');\n        children = _.sortBy(children, 'timestamp', 'desc');\n\n        let i_child = 0;\n        for (let i_parent = 0; i_parent < parents.length; i_parent++) {\n          const p = parents[i_parent];\n          const p_start = moment(p.timestamp);\n          const p_end = p_start.clone().add(p.duration, 'seconds');\n\n          p.children = [];\n          while (i_child < children.length) {\n            const e = children[i_child];\n            const e_start = moment(e.timestamp);\n            const e_end = e_start.clone().add(e.duration, 'seconds');\n\n            const before_parent = e_end.isBefore(p_start);\n            const within_parent = e_start.isAfter(p_start) && e_end.isBefore(p_end);\n            const after_parent = e_start.isAfter(p_end);\n\n            // TODO: This isn't correct, yet\n            if (before_parent) {\n              // Child is behind parent\n              //console.log(\"Too far behind: \" + i_child);\n              i_child++;\n            } else if (within_parent) {\n              //console.log(\"Added relation: \" + i_child);\n              p.children = _.concat(p.children, e);\n              i_child++;\n            } else if (after_parent) {\n              // Child is ahead of parent\n              //console.log(\"Too far ahead: \" + i_child);\n              break;\n            } else {\n              // TODO: Split events when this happens\n              console.warn('Between parents');\n              p.children = _.concat(p.children, e);\n              i_child++;\n            }\n          }\n        }\n\n        // Build the root node\n        //console.log(parents);\n        const m_start = moment(_.first(parents).timestamp);\n        const m_end = moment(_.tail(parents).timestamp);\n        const duration = (m_end - m_start) / 1000;\n        return {\n          timestamp: _.first(parents).timestamp,\n          // TODO: If we want a 12/24h clock, this has to change\n          duration: duration,\n          data: { title: 'ROOT' },\n          children: parents,\n        };\n      }\n\n      this.todaysEvents(this.afkBucketId).then(events_afk => {\n        this.todaysEvents(this.windowBucketId).then(events_window => {\n          let hierarchy = null;\n          if (events_afk.length > 0 && events_window.length > 0) {\n            hierarchy = buildHierarchy(events_afk, events_window);\n            this.centerMsg = 'Hover to inspect';\n          } else {\n            // FIXME: This should do the equivalent of \"No data\" when such is the case, but it doesn't.\n            hierarchy = {\n              timestamp: '',\n              // TODO: If we want a 12/24h clock, this has to change\n              duration: 0,\n              data: { title: 'ROOT' },\n              children: [],\n            };\n            this.centerMsg = 'No data';\n          }\n          sunburst.update(this.$el, hierarchy);\n        });\n      });\n    },\n  },\n};\n</script>\n"]}]}