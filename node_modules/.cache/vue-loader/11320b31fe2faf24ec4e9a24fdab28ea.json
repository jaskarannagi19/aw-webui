{"remainingRequest":"/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/src/visualizations/VisTimeline.vue?vue&type=style&index=0&lang=scss&","dependencies":[{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/src/visualizations/VisTimeline.vue","mtime":1622212604097},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/jaskaran/code/jaskaran/activitywatch/aw-server/aw-webui/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKZGl2I3Zpc3VhbGl6YXRpb24gewogIG1hcmdpbi10b3A6IDAuNWVtOwogIG1hcmdpbi1ib3R0b206IDAuNWVtOwoKICAudGltZWxpbmUtdGltZWxpbmUgewogICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWYgIWltcG9ydGFudDsKCiAgICAudGltZWxpbmUtcGFuZWwgewogICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogICAgfQoKICAgIC50aW1lbGluZS1pdGVtIHsKICAgICAgYm9yZGVyLXJhZGl1czogMnB4OwogICAgfQogIH0KfQo="},{"version":3,"sources":["VisTimeline.vue"],"names":[],"mappings":";;;;;;AAMA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"VisTimeline.vue","sourceRoot":"src/visualizations","sourcesContent":["<template lang=\"pug\">\ndiv\n  div#visualization\n</template>\n\n<style lang=\"scss\">\ndiv#visualization {\n  margin-top: 0.5em;\n  margin-bottom: 0.5em;\n\n  .timeline-timeline {\n    font-family: sans-serif !important;\n\n    .timeline-panel {\n      box-sizing: border-box;\n    }\n\n    .timeline-item {\n      border-radius: 2px;\n    }\n  }\n}\n</style>\n\n<script lang=\"ts\">\nimport _ from 'lodash';\nimport moment from 'moment';\nimport Color from 'color';\nimport { buildTooltip } from '../util/tooltip.js';\nimport { getColorFromString, getTitleAttr } from '../util/color';\n\nimport { Timeline } from 'vis-timeline/esnext';\nimport 'vis-timeline/styles/vis-timeline-graph2d.css';\n\nexport default {\n  props: {\n    buckets: { type: Array },\n    showRowLabels: { type: Boolean },\n    queriedInterval: { type: Array },\n    showQueriedInterval: { type: Boolean },\n  },\n  data() {\n    return {\n      timeline: null,\n      filterShortEvents: true,\n      options: {\n        zoomMin: 1000 * 60, // 10min in milliseconds\n        zoomMax: 1000 * 60 * 60 * 24 * 31 * 3, // about three months in milliseconds\n        stack: false,\n        tooltip: {\n          followMouse: true,\n          overflowMethod: 'cap',\n        },\n      },\n    };\n  },\n  computed: {\n    chartData() {\n      const data = [];\n      _.each(this.buckets, (bucket, bidx) => {\n        if (bucket.events === undefined) {\n          return;\n        }\n        let events = bucket.events;\n        // Filter out events shorter than 1 second (notably including 0-duration events)\n        // TODO: Use flooding instead, preferably with some additional method of removing/simplifying short events for even greater performance\n        if (this.filterShortEvents) {\n          events = _.filter(events, e => e.duration > 1);\n        }\n        events = _.sortBy(events, e => e.timestamp);\n        _.each(events, e => {\n          data.push([\n            bidx,\n            getTitleAttr(bucket, e),\n            buildTooltip(bucket, e),\n            new Date(e.timestamp),\n            new Date(moment(e.timestamp).add(e.duration, 'seconds').valueOf()),\n            getColorFromString(getTitleAttr(bucket, e)),\n          ]);\n        });\n      });\n      return data;\n    },\n  },\n  watch: {\n    buckets() {\n      // For some reason, an object is passed here, after which the correct array arrives\n      if (this.buckets.length === undefined) {\n        //console.log(\"I told you so!\")\n        return;\n      }\n\n      // Build groups\n      const groups = _.map(this.buckets, (bucket, bidx) => {\n        return { id: bidx, content: this.showRowLabels ? bucket.id : '' };\n      });\n\n      // Build items\n      const items = _.map(this.chartData, (row, i) => {\n        const bgColor = row[5];\n        const borderColor = Color(bgColor).darken(0.3);\n        return {\n          id: String(i),\n          group: row[0],\n          content: row[1],\n          title: row[2],\n          start: moment(row[3]),\n          end: moment(row[4]),\n          style: `background-color: ${bgColor}; border-color: ${borderColor}`,\n        };\n      });\n\n      if (groups.length > 0 && items.length > 0) {\n        if (this.queriedInterval && this.showQueriedInterval) {\n          const duration = this.queriedInterval[1].diff(this.queriedInterval[0], 'seconds');\n          groups.push({ id: String(groups.length), content: 'queried interval' });\n          items.push({\n            id: String(items.length + 1),\n            group: groups.length - 1,\n            title: buildTooltip(\n              { type: 'test' },\n              {\n                timestamp: this.queriedInterval[0],\n                duration: duration,\n                data: { title: 'test' },\n              }\n            ),\n            content: 'query',\n            start: this.queriedInterval[0],\n            end: this.queriedInterval[1],\n            style: 'background-color: #aaa; height: 10px',\n          });\n        }\n\n        const start =\n          (this.queriedInterval && this.queriedInterval[0]) ||\n          _.min(_.map(items, item => item.start));\n        const end =\n          (this.queriedInterval && this.queriedInterval[1]) ||\n          _.max(_.map(items, item => item.end));\n        this.options.min = start;\n        this.options.max = end;\n        this.timeline.setOptions(this.options);\n        this.timeline.setWindow(start, end);\n        this.timeline.setData({ groups: groups, items: items });\n      }\n    },\n  },\n  mounted() {\n    this.$nextTick(() => {\n      const el = this.$el.querySelector('#visualization');\n      this.timeline = new Timeline(el, [], [], this.options);\n    });\n  },\n};\n</script>\n"]}]}